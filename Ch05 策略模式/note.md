# 策略模式

## 定义

定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。

## Javascript 中的实现

基本的实现，可以用对象来存储多个算法，其作用类似于python的字典结构，算法名作为对象的属性名，算法作为对象的属性值，从而实现类似算法的索引，也就是“策略的选择”。

例如，在代码例1和例2中，就是用这种方法实现不同计算方法的选择。例2中，各种算法返回的数据结构是一致的，从而使接下来的操作成为可能。

```
                   上一步计算
                        |
           (各个算法具有相同或类似的结构)
                        |
      +-----------+-----+------+-------------+
      |           |            |             |
    算法1        算法2         算法3         算法4
      |           |            |             |
      +-----------+-----+------+-------------+
                        |
               (返回相同的数据结构)
                        |
                  继续下一步处理
```

在例3中，就稍微复杂一点。在这里，预先准备好一些检验算法（注意，不完全等同于检验规则）；然后通过一个对象的修改，实现检验规则的配置。实现了检验规则的动态配置，同时也实现了检验算法的复用。这在实际应用中是比较多的，比如在各种图表库（echarts之类的）中，就经常见到这种配置方法。


## 我的理解

策略模式，本质上是对语言分支结构的一种高级实现。开发语言一般提供基本的分支语法（if...then...else...  switch...等），但是面对分支计算比较复杂的时候，就会给代码维护造成困难，难读、难改、难复用。

第一步，考虑到算法的复用，就把各个算法封装成函数，分支结构中用函数来指代复杂的算法。这解决了代码维护和复用的问题，但是分支结构本身还是比较复杂。

第二步，给每个算法起名字，用某种数据结构（类似字典）把他们集中管理起来。用“算法的名字”来选择算法，而不再使用分支结构。（例1、 2）

第三步，将算法的计算和数据分解开来，形成方法和数据的分离，分别用两套结构来管理。方法这一组，就成为了高度可复用的“算法组”；数据这一组，就成为了因地制宜的“配置项”。对于不同的应用需求，可以使用一个总的“算法组”，而通过配置的不同而形成适应环境需求的“策略”。（例3）

这就是我理解的策略模式。

注意，第二步和第三步并无高下之分，而是满足不同的应用需求。对于复杂多变的场景，用第三步可以减少未来的工作；对于不太复杂的需求，第二步就够用了。

## 策略模式的未来

我们看到，由于动态语言非常灵活，很多设计模式已经内建在语言中了，用不着费心去实现它。这也就是 Python，Javascrpt 用起来比较顺手的原因。那么，在未来，策略模式可能被某种语言内建的特性所替代么？

目前的我，觉得不会。前面说到策略模式形成的机制，是对分支结构的一种高阶模拟。这不会在语言方面完全解决。顶多是通过语法糖来简化代码的编写，同时让编译器能够对这种分支结构进行优化（我觉得这个都没什么必要）。如果通过语法修改，能够满足其灵活应用的特性，必然造成学习难度的提升。所以语言层面的实现不太现实。

但是，为不同场景设计的类库，倒是可以将策略模式用起来。通过对“第三步”的使用，只将策略的配置暴露给使用者，让开发成为一种“配置”，简化类库的应用难度。甚至可以达到“不会语言而会类库”的程度，使开发成为一种“组态”。
