# 命令模式

## 定义

模板方法是一种基于继承的设计模式。

模板方法模式由两部分组成，第一部分是抽象父类，第二部分是具体的实现子类。通常在抽象父类中封装了子类的算法框架，包括实现一些公共方法以及封装子类中所有方法的执行顺序。子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法。

## 在JS中的实现

在JS中，模板方法有两种实现方式。

1. 模拟类的实现方式
    用类函数及其prototype，可以实现类和继承，由此就可以实现模板方法。（参见代码1）

2. 用函数实现的方式
    在JS中，创建对象不一定依靠类，用函数就可以直接创建对象。
    在创建对象的时候，将方法作为参数传入函数，就可以得到覆盖了原有方法的新对象。注意哦，要利用闭包将原型对象保存起来，否则每次都创建新对象，就不是模板方法了。

后者存在一个缺陷，就是在浏览器的控制台中打印出来的时候，无法显示类名。如果是采用F函数构造的，就是F。这虽然只会为程序调试带来些许困难，但是对于强迫症患者来说却是灾难。所以，还是受点儿累，选择前者吧。

## 思考

其实，模板方法这是一种节省空间的方法。试想，大量类似对象中都用到相同的方法，如果在每个对象中都使用一个独立方法，势必造成内存浪费。于是人们就想把发把这些相同的方法做成公用的，以节省空间。

如果把这些公用方法封装成全局变量（或者公用函数），那么可以实现同样的效果，但是带来的问题就是全局变量污染。小程序这样做没有问题，但是大型程序也这么做就会带来麻烦，很可能造成相互覆盖，所以不可取。

在传统的面向对象语言中，可以通过继承机制解决这个问题。在抽象父类中实现公用方法，在具体子类中实现其他方法，在实例中就可以调用了。

而在JS中，也可以通过原型继承机制来实现同样的效果，一个对象上找不到方法的时候，就找原型，一直到null为止。

但是严格按照类的方式来实现（方式2），代码确实算不上优雅。而使用闭包方式（方式2）又看不到类名。很矛盾啊。不知道最新的 class 语法能否解决这个问题。

# PS
在面向对象的程序设计中，通常是由架构师来实现模板（抽象父类），这样就给整个程序搭建了框架。之后再由程序员来负责实现具体类就不会出现太大偏差了。