# 职责链模式

## 定义

使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，
将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。

## 适用条件

书中的例子都是多重条件语句的情况下，使用职责链的方法。

如果不用职责链的话，就要面对多层嵌套的条件语句。

## 传统实现方法

在传统面向对象语言中，我们用一个 Chain （链环）类，实现职责链的各个环节。
同时，为了避免职责链的各环节的耦合，我们让每个环节返回特定的信息来标识“进入下一个链环”。

## 在JS中的实现

在js中，我们可以在 Function.prototype 上添加一个 addNext(nextFn) 方法，
让所有函数具备链换的特性，当然，我们还是需要函数返回一个特定的信息来标识“进入下一个链环”。
这个特定信息在 Function.prototype.addNext() 中会用到。

有时候，我们还需要异步的职责链，这就要利用回调函数来实现。
遇到回调，通常没有什么好办法，回调地狱是躲不开的。
不过呢，我尝试在 Function.prototype 上添加了一个 syncAfter 方法，让方法的宿主函数能够成为传入函数的回调

也就是 

    var fx = f2.syncAfter(f1)

把 f2 作为 f1 的回调函数来使用。

## 思考

复杂的条件嵌套，在职责链的帮助下，能否化繁为简。
但是，这也是有代价的，那就是全局变量的引入，那个标识这进入下一个链环的返回值。
我们无论如何绕不开它。

是否值得呢？看实际情况吧。